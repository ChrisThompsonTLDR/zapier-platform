import * as ZFunctions from './functionSignatures';
import { DefaultInputData } from './common';

/* tslint:disable */
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run `yarn gen-defs` in the `core` repo to regenerate this file.
 */

/**
 * Represents a simplified semver string, from `0.0.0` to `999.999.999`.
 */
export type Version = string;
/**
 * List of before or after middlewares. Can be an array of functions or a single function
 */
export type Middlewares = SerializableFunction[] | SerializableFunction;
/**
 * Internal pointer to a function from the original source or the source code itself. Encodes arity and if `arguments` is used in the body. Note - just write normal functions and the system will encode the pointers for you. Or, provide {source: "return 1 + 2"} and the system will wrap in a function for you.
 */
export type SerializableFunction = string | FunctionRequire | FunctionSource;
/**
 * Reference a resource by key and the data it returns. In the format of: `{resource_key}.{foreign_key}(.{human_label_key})`.
 */
export type RefResource = string;
/**
 * A static dropdown of options. Which you use depends on your order and label requirements:
 *
 * Need a Label? | Does Order Matter? | Type to Use
 * ---|---|---
 * Yes | No | Object of value -> label
 * No | Yes | Array of Strings
 * Yes | Yes | Array of [FieldChoiceWithLabel](#fieldchoicewithlabelschema)
 */
export type FieldChoices =
  | {
      [k: string]: unknown;
    }
  | [string | FieldChoiceWithLabel, ...(string | FieldChoiceWithLabel)[]];
/**
 * An array or collection of fields.
 */
export type Fields = Field[];
/**
 * A unique identifier for this item.
 */
export type Key = string;
/**
 * Like [/FieldsSchema](#fieldsschema) but you can provide functions to create dynamic or custom fields.
 */
export type DynamicFields = FieldOrFunction;
/**
 * Represents an array of fields or functions.
 */
export type FieldOrFunction = (Field | SerializableFunction)[];

/**
 * Represents a full app.
 */
export interface ZapierIntegration {
  /**
   * A version identifier for your code.
   */
  version: Version;
  /**
   * A version identifier for the Zapier execution environment.
   */
  platformVersion: Version;
  /**
   * EXPERIMENTAL: Before the perform method is called on your app, you can modify the execution context.
   */
  beforeApp?: Middlewares;
  /**
   * EXPERIMENTAL: After the perform method is called on your app, you can modify the response.
   */
  afterApp?: Middlewares;
  /**
   * Choose what scheme your API uses for authentication.
   */
  authentication?: Authentication;
  /**
   * Define a request mixin, great for setting custom headers, content-types, etc.
   */
  requestTemplate?: RequestObj;
  /**
   * Before an HTTP request is sent via our `z.request()` client, you can modify it.
   */
  beforeRequest?: Array<
    ZFunctions.NoStrings<
      | ZFunctions.BeforeRequestMiddlewareFunction
      | RequestObj
      | SerializableFunction
    >
  >;
  /**
   * After an HTTP response is recieved via our `z.request()` client, you can modify it.
   */
  afterResponse?: Array<
    ZFunctions.AfterMiddlewareFunction | RequestObj | SerializableFunction
  >;
  /**
   * An optional bank of named functions that you can use in `z.hydrate('someName')` to lazily load data.
   */
  hydrators?: Hydrators;
  /**
   * All the resources for your app. Zapier will take these and generate the relevent triggers/searches/creates automatically.
   */
  resources?: Resources;
  /**
   * All the triggers for your app. You can add your own here, or Zapier will automatically register any from the list/hook methods on your resources.
   */
  triggers?: Triggers;
  /**
   * All the searches for your app. You can add your own here, or Zapier will automatically register any from the search method on your resources.
   */
  searches?: Searches;
  /**
   * All the creates for your app. You can add your own here, or Zapier will automatically register any from the create method on your resources.
   */
  creates?: Creates;
  /**
   * All the search-or-create combos for your app. You can create your own here, or Zapier will automatically register any from resources that define a search, a create, and a get (or define a searchOrCreate directly). Register non-resource search-or-creates here as well.
   */
  searchOrCreates?: SearchOrCreates;
  /**
   * Top-level app options
   */
  flags?: AppFlags;
  /**
   * **INTERNAL USE ONLY**. Zapier uses this to hold properties from a legacy Web Builder app.
   */
  legacy?: {
    [k: string]: unknown;
  };
}
/**
 * A path to a file that might have content like `module.exports = (z, bundle) => [{id: 123}];`.
 */
export interface FunctionRequire {
  require: string;
}
/**
 * Source code like `{source: "return 1 + 2"}` which the system will wrap in a function for you.
 */
export interface FunctionSource {
  /**
   * JavaScript code for the function body. This must end with a `return` statement.
   */
  source: string;
  /**
   * Function signature. Defaults to `['z', 'bundle']` if not specified.
   */
  args?: string[];
}
/**
 * Represents authentication schemes.
 */
export interface Authentication {
  /**
   * Choose which scheme you want to use.
   */
  type: 'basic' | 'custom' | 'digest' | 'oauth1' | 'oauth2' | 'session';
  /**
   * A function or request that confirms the authentication is working.
   */
  test: RequestObj | SerializableFunction;
  /**
   * Fields you can request from the user before they connect your app to Zapier.
   */
  fields?: Fields;
  /**
   * A string with variables, function, or request that returns the connection label for the authenticated user.
   */
  connectionLabel?: RequestObj | SerializableFunction | string;
  basicConfig?: AuthenticationBasicConfig;
  customConfig?: AuthenticationCustomConfig;
  digestConfig?: AuthenticationDigestConfig;
  oauth1Config?: AuthenticationOAuth1Config;
  oauth2Config?: AuthenticationOAuth2Config;
  sessionConfig?: AuthenticationSessionConfig;
}
/**
 * A representation of a HTTP request - you can use the `{{syntax}}` to inject authentication, field or global variables.
 */
export interface RequestObj {
  /**
   * The HTTP method for the request.
   */
  method?: 'GET' | 'PUT' | 'POST' | 'PATCH' | 'DELETE' | 'HEAD';
  /**
   * A URL for the request (we will parse the querystring and merge with params). Keys and values will not be re-encoded.
   */
  url?: string;
  /**
   * Can be nothing, a raw string or JSON (object or array).
   */
  body?:
    | null
    | string
    | {
        [k: string]: unknown;
      }
    | unknown[];
  /**
   * A mapping of the querystring - will get merged with any query params in the URL. Keys and values will be encoded.
   */
  params?: FlatObject;
  /**
   * The HTTP headers for the request.
   */
  headers?: FlatObject;
  /**
   * An object holding the auth parameters for OAuth1 request signing, like `{oauth_token: 'abcd', oauth_token_secret: '1234'}`. Or an array reserved (i.e. not implemented yet) to hold the username and password for Basic Auth. Like `['AzureDiamond', 'hunter2']`.
   */
  auth?: string[] | FlatObject;
  /**
   * Should missing values be sent? (empty strings, `null`, and `undefined` only â€” `[]`, `{}`, and `false` will still be sent). Allowed fields are `params` and `body`. The default is `false`, ex: ```removeMissingValuesFrom: { params: false, body: false }```
   */
  removeMissingValuesFrom?: {
    /**
     * Refers to data sent via a requests query params (`req.params`)
     */
    params?: boolean;
    /**
     * Refers to tokens sent via a requsts body (`req.body`)
     */
    body?: boolean;
  };
  /**
   * A function to customize how to serialize a value for curlies `{{var}}` in the request object. By default, when this is unspecified, the request client only replaces curlies where variables are strings, and would throw an error for non-strings. The function should accepts a single argument as the value to be serialized and return the string representation of the argument.
   */
  serializeValueForCurlies?: SerializableFunction;
  /**
   * If `true`, don't throw an exception for response 400 <= status < 600 automatically before resolving with the response. Defaults to `false`.
   */
  skipThrowForStatus?: boolean;
}
/**
 * An object whose values can only be primitives
 */
export interface FlatObject {
  /**
   * Any key may exist in this flat object as long as its values are simple.
   *
   * This interface was referenced by `FlatObject`'s JSON-Schema definition
   * via the `patternProperty` "[^\s]+".
   */
  [k: string]: null | string | number | boolean;
}
/**
 * Defines a field an app either needs as input, or gives as output. In addition to the requirements below, the following keys are mutually exclusive:
 *
 * * `children` & `list`
 * * `children` & `dict`
 * * `children` & `type`
 * * `children` & `placeholder`
 * * `children` & `helpText`
 * * `children` & `default`
 * * `dict` & `list`
 * * `dynamic` & `dict`
 * * `dynamic` & `choices`
 */
export interface Field {
  /**
   * A unique machine readable key for this value (IE: "fname").
   */
  key: string;
  /**
   * A human readable label for this value (IE: "First Name").
   */
  label?: string;
  /**
   * A human readable description of this value (IE: "The first part of a full name."). You can use Markdown.
   */
  helpText?: string;
  /**
   * The type of this value.
   */
  type?:
    | 'string'
    | 'text'
    | 'integer'
    | 'number'
    | 'boolean'
    | 'datetime'
    | 'file'
    | 'password'
    | 'copy';
  /**
   * If this value is required or not.
   */
  required?: boolean;
  /**
   * An example value that is not saved.
   */
  placeholder?: string;
  /**
   * A default value that is saved the first time a Zap is created.
   */
  default?: string;
  /**
   * A reference to a trigger that will power a dynamic dropdown.
   */
  dynamic?: RefResource;
  /**
   * A reference to a search that will guide the user to add a search step to populate this field when creating a Zap.
   */
  search?: RefResource;
  /**
   * An object of machine keys and human values to populate a static dropdown.
   */
  choices?: FieldChoices;
  /**
   * Acts differently when used in inputFields vs. when used in outputFields. In inputFields: Can a user provide multiples of this field? In outputFields: Does this field return an array of items of type `type`?
   */
  list?: boolean;
  /**
   * An array of child fields that define the structure of a sub-object for this field. Usually used for line items.
   */
  children?: [Field, ...Field[]];
  /**
   * Is this field a key/value input?
   */
  dict?: boolean;
  /**
   * Is this field automatically populated (and hidden from the user)?
   */
  computed?: boolean;
  /**
   * Does the value of this field affect the definitions of other fields in the set?
   */
  altersDynamicFields?: boolean;
  /**
   * Useful when you expect the input to be part of a longer string. Put "{{input}}" in place of the user's input (IE: "https://{{input}}.yourdomain.com").
   */
  inputFormat?: string;
}
/**
 * An object describing a labeled choice in a static dropdown. Useful if the value a user picks isn't exactly what the zap uses. For instance, when they click on a nickname, but the zap uses the user's full name ([image](https://cdn.zapier.com/storage/photos/8ed01ac5df3a511ce93ed2dc43c7fbbc.png)).
 */
export interface FieldChoiceWithLabel {
  /**
   * The actual value that is sent into the Zap. Should match sample exactly.
   */
  value: string;
  /**
   * Displayed as light grey text in the editor. It's important that the value match the sample. Otherwise, the actual value won't match what the user picked, which is confusing.
   */
  sample: string;
  /**
   * A human readable label for this value.
   */
  label: string;
  [k: string]: unknown;
}
/**
 * Config for Basic Authentication. No extra properties are required to setup Basic Auth, so you can leave this empty if your app uses Basic Auth.
 */
export interface AuthenticationBasicConfig {}
/**
 * Config for custom authentication (like API keys). No extra properties are required to setup this auth type, so you can leave this empty if your app uses a custom auth method.
 */
export interface AuthenticationCustomConfig {}
/**
 * Config for Digest Authentication. No extra properties are required to setup Digest Auth, so you can leave this empty if your app uses Digets Auth.
 */
export interface AuthenticationDigestConfig {}
/**
 * Config for OAuth1 authentication.
 */
export interface AuthenticationOAuth1Config {
  /**
   * Define where Zapier will acquire a request token which is used for the rest of the three legged authentication process.
   */
  getRequestToken: RequestObj | SerializableFunction;
  /**
   * Define where Zapier will redirect the user to authorize our app. Typically, you should append an `oauth_token` querystring parameter to the request.
   */
  authorizeUrl: RedirectRequest | SerializableFunction;
  /**
   * Define how Zapier fetches an access token from the API
   */
  getAccessToken: RequestObj | SerializableFunction;
}
/**
 * A representation of a HTTP redirect - you can use the `{{syntax}}` to inject authentication, field or global variables.
 */
export interface RedirectRequest {
  /**
   * The HTTP method for the request.
   */
  method?: 'GET';
  /**
   * A URL for the request (we will parse the querystring and merge with params). Keys and values will not be re-encoded.
   */
  url?: string;
  /**
   * A mapping of the querystring - will get merged with any query params in the URL. Keys and values will be encoded.
   */
  params?: FlatObject;
}
/**
 * Config for OAuth2 authentication.
 */
export interface AuthenticationOAuth2Config {
  /**
   * Define where Zapier will redirect the user to authorize our app. Note: we append the redirect URL and state parameters to return value of this function.
   */
  authorizeUrl: RedirectRequest | SerializableFunction;
  /**
   * Define how Zapier fetches an access token from the API
   */
  getAccessToken: RequestObj | SerializableFunction;
  /**
   * Define how Zapier will refresh the access token from the API
   */
  refreshAccessToken?: RequestObj | SerializableFunction;
  /**
   * What scope should Zapier request?
   */
  scope?: string;
  /**
   * Should Zapier invoke `refreshAccessToken` when we receive an error for a 401 response?
   */
  autoRefresh?: boolean;
}
/**
 * Config for session authentication.
 */
export interface AuthenticationSessionConfig {
  /**
   * Define how Zapier fetches the additional authData needed to make API calls.
   */
  perform: RequestObj | SerializableFunction;
}
/**
 * A bank of named functions that you can use in `z.hydrate('someName')` to lazily load data.
 */
export interface Hydrators {
  /**
   * Any unique key can be used in `z.hydrate('uniqueKeyHere')`.
   *
   * This interface was referenced by `Hydrators`'s JSON-Schema definition
   * via the `patternProperty` "^[a-zA-Z]+[a-zA-Z0-9]*$".
   */
  [k: string]: SerializableFunction;
}
/**
 * All the resources that underlie common CRUD methods powering automatically handled triggers, creates, and searches for your app. Zapier will break these apart for you.
 */
export interface Resources {
  /**
   * Any unique key can be used and its values will be validated against the ResourceSchema.
   *
   * This interface was referenced by `Resources`'s JSON-Schema definition
   * via the `patternProperty` "^[a-zA-Z]+[a-zA-Z0-9_]*$".
   */
  [k: string]: Resource;
}
/**
 * Represents a resource, which will in turn power triggers, searches, or creates.
 */
export interface Resource {
  /**
   * A key to uniquely identify this resource.
   */
  key: Key;
  /**
   * A noun for this resource that completes the sentence "create a new XXX".
   */
  noun: string;
  /**
   * How will we get a single object given a unique identifier/id?
   */
  get?: ResourceMethodGet;
  /**
   * How will we get notified of new objects? Will be turned into a trigger automatically.
   */
  hook?: ResourceMethodHook;
  /**
   * How will we get a list of new objects? Will be turned into a trigger automatically.
   */
  list?: ResourceMethodList;
  /**
   * How will we find a specific object given filters or search terms? Will be turned into a search automatically.
   */
  search?: ResourceMethodSearch;
  /**
   * How will we find create a specific object given inputs? Will be turned into a create automatically.
   */
  create?: ResourceMethodCreate;
  /**
   * What fields of data will this return?
   */
  outputFields?: DynamicFields;
  /**
   * What does a sample of data look like?
   */
  sample?: {
    [k: string]: unknown;
  };
}
/**
 * How will we get a single object given a unique identifier/id?
 */
export interface ResourceMethodGet {
  /**
   * Define how this get method will be exposed in the UI.
   */
  display: BasicDisplay;
  /**
   * Define how this get method will work.
   */
  operation: BasicOperation;
}
/**
 * Represents user information for a trigger, search, or create.
 */
export interface BasicDisplay {
  /**
   * A short label like "New Record" or "Create Record in Project". Optional if `hidden` is true.
   */
  label?: string;
  /**
   * A description of what this trigger, search, or create does. Optional if `hidden` is true.
   */
  description?: string;
  /**
   * A short blurb that can explain how to get this working. EG: how and where to copy-paste a static hook URL into your application. Only evaluated for static webhooks.
   */
  directions?: string;
  /**
   * Affects how prominently this operation is displayed in the UI. Only mark a few of the most popular operations important.
   */
  important?: boolean;
  /**
   * Should this operation be unselectable by users?
   */
  hidden?: boolean;
}
/**
 * Represents the fundamental mechanics of triggers, searches, or creates.
 */
export interface BasicOperation {
  /**
   * Optionally reference and extends a resource. Allows Zapier to automatically tie together samples, lists and hooks, greatly improving the UX. EG: if you had another trigger reusing a resource but filtering the results.
   */
  resource?: Key;
  /**
   * How will Zapier get the data? This can be a function like `(z) => [{id: 123}]` or a request like `{url: 'http...'}`.
   */
  perform: RequestObj | SerializableFunction;
  /**
   * What should the form a user sees and configures look like?
   */
  inputFields?: DynamicFields;
  /**
   * What fields of data will this return? Will use resource outputFields if missing, will also use sample if available.
   */
  outputFields?: DynamicFields;
  /**
   * What does a sample of data look like? Will use resource sample if missing. Requirement waived if `display.hidden` is true or if this belongs to a resource that has a top-level sample
   */
  sample?: {
    [k: string]: unknown;
  };
}
/**
 * How will we get notified of new objects? Will be turned into a trigger automatically.
 */
export interface ResourceMethodHook {
  /**
   * Define how this hook/trigger method will be exposed in the UI.
   */
  display: BasicDisplay;
  /**
   * Define how this hook/trigger method will work.
   */
  operation: BasicHookOperation;
}
/**
 * Represents the inbound mechanics of hooks with optional subscribe/unsubscribe. Defers to list for fields.
 */
export interface BasicHookOperation {
  /**
   * Must be explicitly set to `"hook"` unless this hook is defined as part of a resource, in which case it's optional.
   */
  type?: 'hook';
  /**
   * Optionally reference and extends a resource. Allows Zapier to automatically tie together samples, lists and hooks, greatly improving the UX. EG: if you had another trigger reusing a resource but filtering the results.
   */
  resource?: Key;
  /**
   * A function that processes the inbound webhook request.
   */
  perform: RequestObj | SerializableFunction;
  /**
   * Can get "live" data on demand instead of waiting for a hook. If you find yourself reaching for this - consider resources and their built-in hook/list methods. Note: this is required for public apps to ensure the best UX for the end-user. For private apps, you can ignore warnings about this property with the `--without-style` flag during `zapier push`.
   */
  performList?: RequestObj | SerializableFunction;
  /**
   * Takes a URL and any necessary data from the user and subscribes. Note: this is required for public apps to ensure the best UX for the end-user. For private apps, you can ignore warnings about this property with the `--without-style` flag during `zapier push`.
   */
  performSubscribe?: RequestObj | SerializableFunction;
  /**
   * Takes a URL and data from a previous subscribe call and unsubscribes. Note: this is required for public apps to ensure the best UX for the end-user. For private apps, you can ignore warnings about this property with the `--without-style` flag during `zapier push`.
   */
  performUnsubscribe?: RequestObj | SerializableFunction;
  /**
   * What should the form a user sees and configures look like?
   */
  inputFields?: DynamicFields;
  /**
   * What fields of data will this return? Will use resource outputFields if missing, will also use sample if available.
   */
  outputFields?: DynamicFields;
  /**
   * What does a sample of data look like? Will use resource sample if missing. Requirement waived if `display.hidden` is true or if this belongs to a resource that has a top-level sample
   */
  sample?: {
    [k: string]: unknown;
  };
}
/**
 * How will we get a list of new objects? Will be turned into a trigger automatically.
 */
export interface ResourceMethodList {
  /**
   * Define how this list/trigger method will be exposed in the UI.
   */
  display: BasicDisplay;
  /**
   * Define how this list/trigger method will work.
   */
  operation: BasicPollingOperation;
}
/**
 * Represents the fundamental mechanics of a trigger.
 */
export interface BasicPollingOperation {
  /**
   * Clarify how this operation works (polling == pull or hook == push).
   */
  type?: 'polling';
  /**
   * Optionally reference and extends a resource. Allows Zapier to automatically tie together samples, lists and hooks, greatly improving the UX. EG: if you had another trigger reusing a resource but filtering the results.
   */
  resource?: Key;
  /**
   * How will Zapier get the data? This can be a function like `(z) => [{id: 123}]` or a request like `{url: 'http...'}`.
   */
  perform:
    | ZFunctions.TriggerOperationPerformFunc
    | RequestObj
    | SerializableFunction;
  /**
   * Does this endpoint support a page offset?
   */
  canPaginate?: boolean;
  /**
   * What should the form a user sees and configures look like?
   */
  inputFields?: DynamicFields;
  /**
   * What fields of data will this return? Will use resource outputFields if missing, will also use sample if available.
   */
  outputFields?: DynamicFields;
  /**
   * What does a sample of data look like? Will use resource sample if missing. Requirement waived if `display.hidden` is true or if this belongs to a resource that has a top-level sample
   */
  sample?: {
    [k: string]: unknown;
  };
}
/**
 * How will we find a specific object given filters or search terms? Will be turned into a search automatically.
 */
export interface ResourceMethodSearch {
  /**
   * Define how this search method will be exposed in the UI.
   */
  display: BasicDisplay;
  /**
   * Define how this search method will work.
   */
  operation: BasicActionOperation;
}
/**
 * Represents the fundamental mechanics of a search/create.
 */
export interface BasicActionOperation {
  /**
   * Optionally reference and extends a resource. Allows Zapier to automatically tie together samples, lists and hooks, greatly improving the UX. EG: if you had another trigger reusing a resource but filtering the results.
   */
  resource?: Key;
  /**
   * How will Zapier get the data? This can be a function like `(z) => [{id: 123}]` or a request like `{url: 'http...'}`.
   */
  perform: RequestObj | SerializableFunction;
  /**
   * A function that parses data from a perform + callback to resume this action. For use with callback semantics
   */
  performResume?: SerializableFunction;
  /**
   * How will Zapier get a single record? If you find yourself reaching for this - consider resources and their built-in get methods.
   */
  performGet?: RequestObj | SerializableFunction;
  /**
   * What should the form a user sees and configures look like?
   */
  inputFields?: DynamicFields;
  /**
   * What fields of data will this return? Will use resource outputFields if missing, will also use sample if available.
   */
  outputFields?: DynamicFields;
  /**
   * What does a sample of data look like? Will use resource sample if missing. Requirement waived if `display.hidden` is true or if this belongs to a resource that has a top-level sample
   */
  sample?: {
    [k: string]: unknown;
  };
}
/**
 * How will we find create a specific object given inputs? Will be turned into a create automatically.
 */
export interface ResourceMethodCreate {
  /**
   * Define how this create method will be exposed in the UI.
   */
  display: BasicDisplay;
  /**
   * Define how this create method will work.
   */
  operation: BasicActionOperation;
}
/**
 * Enumerates the triggers your app has available for users.
 */
export interface Triggers {
  /**
   * Any unique key can be used and its values will be validated against the TriggerSchema.
   *
   * This interface was referenced by `Triggers`'s JSON-Schema definition
   * via the `patternProperty` "^[a-zA-Z]+[a-zA-Z0-9_]*$".
   */
  [k: string]: Trigger;
}
/**
 * How will Zapier get notified of new objects?
 */
export interface Trigger {
  /**
   * A key to uniquely identify this trigger.
   */
  key: Key;
  /**
   * A noun for this trigger that completes the sentence "triggers on a new XXX".
   */
  noun: string;
  /**
   * Configures the UI for this trigger.
   */
  display: BasicDisplay;
  /**
   * Powers the functionality for this trigger.
   */
  operation: BasicPollingOperation | BasicHookOperation;
}
/**
 * Enumerates the searches your app has available for users.
 */
export interface Searches {
  /**
   * Any unique key can be used and its values will be validated against the SearchSchema.
   *
   * This interface was referenced by `Searches`'s JSON-Schema definition
   * via the `patternProperty` "^[a-zA-Z]+[a-zA-Z0-9_]*$".
   */
  [k: string]: Search;
}
/**
 * How will Zapier search for existing objects?
 */
export interface Search {
  /**
   * A key to uniquely identify this search.
   */
  key: Key;
  /**
   * A noun for this search that completes the sentence "finds a specific XXX".
   */
  noun: string;
  /**
   * Configures the UI for this search.
   */
  display: BasicDisplay;
  /**
   * Powers the functionality for this search.
   */
  operation: BasicActionOperation;
}
/**
 * Enumerates the creates your app has available for users.
 */
export interface Creates {
  /**
   * Any unique key can be used and its values will be validated against the CreateSchema.
   *
   * This interface was referenced by `Creates`'s JSON-Schema definition
   * via the `patternProperty` "^[a-zA-Z]+[a-zA-Z0-9_]*$".
   */
  [k: string]: Create;
}
/**
 * How will Zapier create a new object?
 */
export interface Create {
  /**
   * A key to uniquely identify this create.
   */
  key: Key;
  /**
   * A noun for this create that completes the sentence "creates a new XXX".
   */
  noun: string;
  /**
   * Configures the UI for this create.
   */
  display: BasicDisplay;
  /**
   * Powers the functionality for this create.
   */
  operation: BasicCreateActionOperation;
}
/**
 * Represents the fundamental mechanics of a create.
 */
export interface BasicCreateActionOperation {
  /**
   * Optionally reference and extends a resource. Allows Zapier to automatically tie together samples, lists and hooks, greatly improving the UX. EG: if you had another trigger reusing a resource but filtering the results.
   */
  resource?: Key;
  /**
   * How will Zapier get the data? This can be a function like `(z) => [{id: 123}]` or a request like `{url: 'http...'}`.
   */
  perform: RequestObj | SerializableFunction;
  /**
   * A function that parses data from a perform + callback to resume this action. For use with callback semantics
   */
  performResume?: SerializableFunction;
  /**
   * How will Zapier get a single record? If you find yourself reaching for this - consider resources and their built-in get methods.
   */
  performGet?: RequestObj | SerializableFunction;
  /**
   * What should the form a user sees and configures look like?
   */
  inputFields?: DynamicFields;
  /**
   * What fields of data will this return? Will use resource outputFields if missing, will also use sample if available.
   */
  outputFields?: DynamicFields;
  /**
   * What does a sample of data look like? Will use resource sample if missing. Requirement waived if `display.hidden` is true or if this belongs to a resource that has a top-level sample
   */
  sample?: {
    [k: string]: unknown;
  };
  /**
   * Should this action be performed one at a time (avoid concurrency)?
   */
  shouldLock?: boolean;
}
/**
 * Enumerates the search-or-creates your app has available for users.
 */
export interface SearchOrCreates {
  /**
   * Any unique key can be used and its values will be validated against the SearchOrCreateSchema.
   *
   * This interface was referenced by `SearchOrCreates`'s JSON-Schema definition
   * via the `patternProperty` "^[a-zA-Z]+[a-zA-Z0-9_]*$".
   */
  [k: string]: SearchOrCreate;
}
/**
 * Pair an existing search and a create to enable "Find or Create" functionality in your app
 */
export interface SearchOrCreate {
  /**
   * A key to uniquely identify this search-or-create. Must match the search key.
   */
  key: Key;
  /**
   * Configures the UI for this search-or-create.
   */
  display: BasicDisplay;
  /**
   * The key of the search that powers this search-or-create
   */
  search: Key;
  /**
   * The key of the create that powers this search-or-create
   */
  create: Key;
}
/**
 * Codifies high-level options for your app.
 */
export interface AppFlags {
  /**
   * By default, Zapier patches the core `http` module so that all requests (including those from 3rd-party SDKs) can be logged. Set this to true if you're seeing issues using an SDK (such as AWS).
   */
  skipHttpPatch?: boolean;
}
